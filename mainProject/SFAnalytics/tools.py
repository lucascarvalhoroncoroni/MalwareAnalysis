import math
import subprocess
import re
import hashlib
import pefile
import time
import math
from multiprocessing import Process
from multiprocessing import Queue

class HandleFile(object):
    #handling an upload
    @staticmethod
    def saveFile(data, path):
        destination =  open('{}{}'.format(path, data.name), 'wb+')
        for chunk in data.chunks():
            destination.write(chunk)

        destination.close()

#This classes helps with the porcentage of opcodes
#Operation is a struct to hold an operation name and number of times it is in a file
class Operation(object):
    def __init__(self, op, num):
        self.op = op
        self.num = num

#Operations holds all of the Operations objects as a list
class Operations(object):
    def __init__(self):
        self.operations = []
    """This method adds a new opertion to a list of operations"""
    def insertion(self, instructionName):
        for operation in self.operations:
            if operation.op == instructionName:
                operation.num += 1
                return
        instruction = Operation(op=instructionName, num=1)
        self.operations.append(instruction)


#improve this to get file locations and path
class OpCodeFile(object):
    def __init__(self, path):
        #Chaging to windows path format
        path = re.sub(r'/', '\\\\', path)
        #subprocess.run executes a cmd command : ['.\objdump.exe', '-d','7zFM.exe']
        out = subprocess.run(['C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\Tools\\objdump.exe', '-d', path], stdout=subprocess.PIPE, shell=True)
        self.retcode = out.returncode
        decodedStdout = out.stdout.decode().splitlines()
        self.opcodes = []
        self.operations = Operations()
        for o in decodedStdout:
            i = re.findall(r'\d*:\t.*\t(.*?)\s', o)
            if i:
                self.__selectOperation(i[0])

        self.count = len(self.opcodes)

    def __validOpcode(self, opcode):
        if opcode == 'and':
            return True

        if opcode == 'xor':
            return True

        if opcode == 'retn':
            return True

        if opcode == 'jnz':
            return True

        if opcode == 'add':
            return True

        if opcode == 'jmp':
            return True

        if opcode == 'test':
            return True

        if opcode == 'lea':
            return True

        if opcode == 'jz':
            return True

        if opcode == 'cmp':
            return True

        if opcode == 'pop':
            return True

        if opcode == 'call':
            return True

        if opcode == 'push':
            return True

        if opcode == 'mov':
            return True

        if opcode == 'sub':
            return True

        return False

    def __selectOperation(self, opcode):
        if self.__validOpcode(opcode):
            self.opcodes.append(opcode)
            self.operations.insertion(opcode)

    def getReturnCode(self):
        return self.retcode

    def getOpcodes(self):
        return self.opcodes

    def getCount(self):
        return self.count

    def getOperations(self):
        """"This method returns a list with operation name and a number of times this operation is found in a executable"""
        return self.operations.operations

class HashTable(object):
    """This class is responsible to extract the hash of a file"""
    def __init__(self, path):
        md5 = hashlib.md5()
        sha256 = hashlib.sha256()
        with open(path, 'rb') as afile:
            buf = afile.read()
            while len(buf) > 0:
                md5.update(buf)
                sha256.update(buf)
                buf = afile.read()
            afile.close()

        self.md5 = md5.hexdigest()
        self.sha256 = sha256.hexdigest()

    def getHashMd5(self):
        return self.md5

    def getHashSha256(self):
        return self.sha256

class Strings(object):
    def __init__(self, path):
        self.strings = []
        self.randStr = []
        with open(path, 'rb') as afile:
            buff = afile.read(1)
            string = ''
            while len(buff) > 0:
                byte = buff[0]
                while byte < 127 and byte >= 32:
                    string = string + '' + chr(byte)
                    buff = afile.read(1)
                    if len(buff) == 0:
                        break;
                    byte = buff[0]
                if len(string) >= 4:
                    self.strings.append(string)
                    self.randStr.append(string)
                if len(buff) == 0:
                    break;
                buff = afile.read(1)
                string = ''

        self.count = len(self.strings)
        #self.__randonlySelectStr()

    def __random(self, length):
        tb = time.time()
        time.sleep(0.001)
        ta = time.time()
        elapsedMicro = math.floor((ta - tb) * 10000000)
        pos = (elapsedMicro * 137) % length
        return pos

    def __randonlySelectStr(self):
        strings = []
        #If the file has more than 500 strings
        if len(self.strings) > 500:
            for i in range(500):
                x = self.__random(len(self.randStr))
                strings.append(self.randStr[x])
                del self.randStr[x]
            self.randStr = strings

    def getRandStrings(self):
        return self.randStr

    def getStrings(self):
        return self.strings

    def getCount(self):
        return self.count

def processPEHandleCaller(path):
    """Function used to start a process to use processPEHandle and terminate it to avoid thread problems from pefile. This function returns a PEUtils object"""
    queue = Queue()
    process = Process(target=processPEHandle, args=(path,queue,))
    process.start()
    dataSectionEntropy = queue.get()
    textSectionEntropy = queue.get()
    dlls = queue.get()
    process.terminate()
    return PEUtils(dlls, dataSectionEntropy, textSectionEntropy)

def processPEHandle(path, queue):
    """Function used to extract important data from pefile and send it back throw the queue"""
    p = PEHandle(path)
    queue.put(p.getDataSectionEntropy())
    queue.put(p.getTextSectionEntropy())
    queue.put(p.getDlls())

class PEUtils(object):
    def __init__(self, dlls, dataSectionEntropy, textSectionEntropy):
        """Class used as a struct returned from processPEHandleCaller"""
        self.dlls = dlls
        self.dataSectionEntropy = dataSectionEntropy
        self.textSectionEntropy = textSectionEntropy

    def getDataSectionEntropy(self):
        return self.dataSectionEntropy

    def getTextSectionEntropy(self):
        return self.textSectionEntropy

    def getDlls(self):
        return self.dlls


class PEHandle(object):
    def __init__(self, path):
        self.textSectionEntropy = 0
        self.dataSectionEntropy = 0
        self.textBytesList = []
        self.dataBytesList = []
        self.dlls = []
        try:
            self.portableExecutable = pefile.PE(path)
            if hasattr(self.portableExecutable, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in self.portableExecutable.DIRECTORY_ENTRY_IMPORT:
                    self.dlls.append(entry.dll.decode())

                for section in self.portableExecutable.sections:
                    textSection = re.findall(r'.text*',section.Name.decode())
                    if textSection:
                        self.textBytesList = self.__byteListOfSection(section.get_data())
                        self.textSectionEntropy = self.__bytesEntropy(self.textBytesList)
                    else:
                        dataSection =  re.findall(r'.data*',section.Name.decode())
                        if dataSection:
                            self.dataBytesList = self.__byteListOfSection(section.get_data())
                            self.dataSectionEntropy = self.__bytesEntropy(self.dataBytesList)
        except:
            pass

    #This method makes a list with the data from PESection
    def __byteListOfSection(self, bytesOfSection):
        r = []
        for b in bytesOfSection:
            r.append(b)
        return r

    #This method takes a section list, and calculates the shannon entropy
    def __bytesEntropy(self, bytesListOfSection):
        """The shannon entropy is used to measure the randonness, it uses the sequence distribution to do it."""
        sizeOfBytesListOfSection = len(bytesListOfSection)
        if sizeOfBytesListOfSection > 0:
            #shannon entropy
            freqList = []
            for b in range(256):
                ctr = 0
                for byte in bytesListOfSection:
                    if byte == b:
                        ctr += 1
                freqList.append(ctr / len(bytesListOfSection))
            ent = 0.0
            for freq in freqList:
                if freq > 0:
                    ent = ent + freq * math.log(freq, 2)
            return -ent

        return 0

    def getPortableExecutable(self):
        return self.portableExecutable

    def getDlls(self):
        return self.dlls

    def getTextBytesList(self):
        return self.textBytesList

    def getDataBytesList(self):
        return self.dataBytesList

    def getTextSectionEntropy(self):
        return self.textSectionEntropy

    def getDataSectionEntropy(self):
        return self.dataSectionEntropy
