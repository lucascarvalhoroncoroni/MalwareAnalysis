import math
import subprocess
import re
import hashlib
import pefile

class HandleFile(object):
    #handling an upload
    @staticmethod
    def saveFile(data, path):
        destination =  open('{}{}'.format(path, data.name), 'wb+')
        for chunk in data.chunks():
            destination.write(chunk)

        destination.close()



#improve this to get file locations and path
class OpCodeFile(object):
    def __init__(self, path):
        #subprocess.run executes a cmd command : ['.\objdump.exe', '-d','7zFM.exe']
        out = subprocess.run(['C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\Tools\\objdump.exe', '-d', path], stdout=subprocess.PIPE, shell=True).stdout.decode().splitlines()
        self.opcodes = []
        for o in out:
            i = re.findall(r'\d*:\t.*\t(.*?)\s', o)
            if i:
                self.opcodes.append(i[0])

        self.count = len(self.opcodes)

    def getOpcodes(self):
        return self.opcodes

    def getCount(self):
        return self.count

class HashTable(object):
    """This class is responsible to extract the hash of a file"""
    def __init__(self, path):
        md5 = hashlib.md5()
        sha256 = hashlib.sha256()
        with open(path, 'rb') as afile:
            buf = afile.read()
            while len(buf) > 0:
                md5.update(buf)
                sha256.update(buf)
                buf = afile.read()
            afile.close()

        self.md5 = md5.hexdigest()
        self.sha256 = sha256.hexdigest()

    def getHashMd5(self):
        return self.md5

    def getHashSha256(self):
        return self.sha256

class Strings(object):
    def __init__(self, path):
        self.strings = []
        with open(path, 'rb') as afile:
            buff = afile.read(1)
            string = ''
            while len(buff) > 0:
                byte = buff[0]
                while byte < 128 and byte >= 32:
                    string = string + '' + chr(byte)
                    buff = afile.read(1)
                    if len(buff) == 0:
                        break;
                    byte = buff[0]
                if len(string) >= 4:
                    self.strings.append(string)
                if len(buff) == 0:
                    break;
                buff = afile.read(1)
                string = ''

        self.count = len(self.strings)

    def getStrings(self):
        return self.strings

    def getCount(self):
        return self.count

class PEHandle(object):
    def __init__(self, path):
        self.portableExecutable = pefile.PE(path)
        self.dlls = []
        if hasattr(self.portableExecutable, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in self.portableExecutable.DIRECTORY_ENTRY_IMPORT:
                self.dlls.append(entry.dll.decode())
                self.textSectionEntropy = 0
                self.dataSectionEntropy = 0
        for section in self.portableExecutable.sections:
            textSection = re.findall(r'.text*',section.Name.decode())
            if textSection:
                self.textBytesList = self.__byteListOfSection(section.get_data())
                self.textSectionEntropy = self.__bytesEntropy(self.textBytesList)
            else:
                dataSection =  re.findall(r'.data*',section.Name.decode())
                if dataSection:
                    self.dataBytesList = self.__byteListOfSection(section.get_data())
                    self.dataSectionEntropy = self.__bytesEntropy(self.dataBytesList)

    def __byteListOfSection(self, bytesOfSection):
        r = []
        for b in bytesOfSection:
            r.append(b)
        return r

    def __bytesEntropy(self, bytesListOfSection):
        #shannon entropy
        freqList = []
        for b in range(256):
            ctr = 0
            for byte in bytesListOfSection:
                if byte == b:
                    ctr += 1
            freqList.append(ctr / len(bytesListOfSection))
        ent = 0.0
        for freq in freqList:
            if freq > 0:
                ent = ent + freq * math.log(freq, 2)
        return -ent

    def getPortableExecutable(self):
        return self.portableExecutable

    def getDlls(self):
        return self.dlls

    def getTextBytesList(self):
        return self.textBytesList

    def getDataBytesList(self):
        return self.dataBytesList

    def getTextSectionEntropy(self):
        return self.textSectionEntropy

    def getDataSectionEntropy(self):
        return self.dataSectionEntropy
