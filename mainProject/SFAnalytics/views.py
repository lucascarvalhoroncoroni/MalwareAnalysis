import ctypes
import math
import numpy
import os
import matplotlib.pyplot
from django.shortcuts import render
from django.http import HttpResponseRedirect
from sklearn import tree
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA
from sklearn.datasets import load_iris
from .forms import *
from .tools import *
from .models import *
import graphviz


#struct for each line of the info showing
class OpCodeViewLine(object):
    def __init__(self, name, porcentage, index):
        self.name = name
        self.index = index
        self.porcentage = porcentage

#class for showing opcodes as features
class OpCodeView(object):
    #Extracting features
    def __init__(self, path):
        opcode = OpCodeFile(path)
        opcodeList = opcode.getOperations()
        self.opcodeCount = opcode.getCount()
        self.opcodeFeatures = OpcodeList.objects.all()
        self.opcodeListView = []
        for singleOpcode in opcodeList:
            name = singleOpcode.op
            porcentage = (singleOpcode.num / self.opcodeCount) * 100
            porcentage = float('{0:.4f}'.format(porcentage))
            index = self.__opcodeFeature(singleOpcode.op)
            self.opcodeListView.append(OpCodeViewLine(name, porcentage, index))

    #Extracting index
    def __opcodeFeature(self, opcode):
        for feature in self.opcodeFeatures:
            if feature.instruction == opcode:
                return feature.id
        return 0

    #Result
    def getOpcodeListView(self):
        return self.opcodeListView

    def getOpcodeCount(self):
        self.opcodeCount

#struct for each string line
class StringViewLine(object):
    def __init__(self, string, index):
        self.string = string
        self.index = index

#class for showing strings as features
class StringView(object):
    def __init__(self, path):
        strings = Strings(path)
        self.stringCount = round(strings.getCount() *  0.1)
        stringList = strings.getStrings()[:self.stringCount]
        self.stringFeatures = StringList.objects.all()
        self.stringListView = []
        for string in stringList:
            index = self.__stringFeature(string)
            self.stringListView.append(StringViewLine(string, index))

    def __stringFeature(self, string):
        for singleString in self.stringFeatures:
            if singleString.string == string:
                return singleString.id
        return 0

    def getStringListView(self):
        return self.stringListView

    def getStringCount(self):
        return self.stringCount

#struct for each dll line
class DllViewLine(object):
    def __init__(self, name, index):
        self.name = name
        self.index = index

#class for showing dlls as features
class DllView(object):
    def __init__(self, path):
        pe = PEHandle(path)
        dllList = pe.getDlls()
        self.dataSectionEntropy = pe.getDataSectionEntropy()
        self.textSectionEntropy = pe.getTextSectionEntropy()
        self.dllFeatures = DllList.objects.all()
        self.dllListView = []
        for dll in dllList:
            index = self.__dllFeature(dll)
            self.dllListView.append(DllViewLine(dll, index))

    def __dllFeature(self, dll):
        for singleDll in self.dllFeatures:
            if singleDll.name == dll:
                return singleDll.id
        return 0

    def getTextSectionEntropy(self):
        return self.textSectionEntropy

    def getDataSectionEntropy(self):
        return self.dataSectionEntropy

    def getDllListView(self):
        return self.dllListView

#class to handle additional information of a fileUpload
class AnalysedFile(object):
    def __init__(self, fileName, dataEntropy, textEntropy, isMalware):
        self.name = fileName
        self.dataSectionEntropy = dataEntropy
        self.textSectionEntropy = textEntropy
        self.isMalware = isMalware

#view from upload template
def uploadView(request):
    if request.method == 'POST':
        #this is a simple way, the next step is to add it to the model
        form = UploadSuspiciousFileForm(request.POST, request.FILES)
        if form.is_valid():
            HandleFile.saveFile(request.FILES['fileUpload'], './SFAnalytics/DataBase/Uploads/')
            return HttpResponseRedirect('/SFAnalytics/malwareResult/')
    else:
        form = UploadSuspiciousFileForm()
    return render(request, 'SFAnalytics/uploadTemplate.html', {'form' : form})

#Test for Tree View
def treeViewTest(request):
    iris = load_iris()
    clf = tree.DecisionTreeClassifier()
    clf = clf.fit(iris.data, iris.target)
    dot_data = tree.export_graphviz(clf, out_file=None, feature_names=iris.feature_names, class_names=iris.target_names, filled=True, rounded=True, special_characters=True)
    graph = graphviz.Source(dot_data)
    graph.format = 'png'
    graph.render('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\mainProject\\SFAnalytics\\static\\img\\tree')
    return render(request, 'SFAnalytics/treeViewTest.html', {'decisionTree' : dot_data})

def precisionPorcentage(resultingFeaturesMatrix, resultingTargetVector, resultingTargetTestVector, classifier):
    """Function to calculate the acuracy of the machine learning algoreithm"""
    hitCounter = 0
    totalEntries = len(resultingTargetVector)
    for j in range(totalEntries):
        result = absclassifier.predict(resultingTargetTestVector[j])
        if resultingTargetVector[j] == result:
            hitCounter+=1
    #Calculating porcentage with 4 decimal points
    return float('{0:.4f}'.format((hitCounter/totalEntries)*100))

def precisionPorcentageVector(malwareFeaturesMatrix, malwaresTestCount, softwareFeaturesMatrix, softwaresTestCount):
    precisionVector = []
    for i in range(5):
        #Malwares to be tested
        malwareRangeLowerIndex = i * int(0.2 * malwaresTestCount)
        malwareRangeUpperIndex = (i + 1) * int(0.2 * malwaresTestCount)
        malwareResultingVector = numpy.delete(malwaresFeaturesMatrix, range(malwareRangeLowerIndex, malwareRangeUpperIndex), axis = 0)
        malwareTestVector = malwareFeaturesMatrix[range(malwareRangeLowerIndex, malwareRangeUpperIndex)]
        malwareTargetVector = [1] * len(malwareResultingVector)
        malwaresTestTargetVector = [1] * len(malwareTestVector)
        #Softwares to be tested
        softwareRangeLowerIndex = i * int(0.2 * softwaresTestCount)
        softwareRangeUpperIndex = (i + 1) * int(0.2 * softwaresTestCount)
        softwaresResultingVector = numpy.delete(softwareFeaturesMatrix, range(softwareRangeLowerIndex, softwareRangeUpperIndex), axis = 0)
        softwareTestVector = softwareFeaturesMatrix[range(softwareRangeLowerIndex, softwareRangeUpperIndex)]
        softwareTargetsVector = [0] * len(softwareResultingVector)
        softwareTestTargetsVector = [0] * len(softwareTestVector)
        #Building learning dataset
        resultingFeaturesMatrix = numpy.vstack(malwareResultingVector, softwaresResultingVector)
        resultingTargetVector = malwareTargetVector + softwareTargetsVector
        resultingTargetTestVector = malwaresTestTargetVector + softwareTestTargetsVector
        #Making the algorithm ready
        classifier = decisionTree.fit(resultingFeaturesMatrix, resultingTargetVector)
        #precisionVector.append(precisionPorcentage(resultingFeaturesMatrix, resultingTargetVector, resultingTargetTestVector, classifier))
    return precisionVector

def dataBaseAnalysis(request):
    """This function represents the view to measure the precision of the Decision Tree"""
    decisionTree = tree.DecisionTreeClassifier()
    dataSet = FeaturesInDataBase()
    testMemberIndexes = []
    dataSetSize = len(dataSet.getFeaturesMatrix())
    malwaresFeaturesMatrix = []
    softwareFeaturesMatrix = []
    i = 0
    for features in dataSet.getFeaturesMatrix():
        if dataSet.getSamplesTargetsVector()[i] == 1:
            malwaresFeaturesMatrix.append(features)
        else:
            softwareFeaturesMatrix.append(features)
        i+=1
    softwareFeaturesMatrix = numpy.array(softwareFeaturesMatrix)
    malwareFeaturesMatrix = numpy.array(malwareFeaturesMatrix)
    softwaresTestCount = len(softwareFeaturesMatrix)
    malwaresTestCount = len(malwaresFeaturesMatrix)
    #This holds the results from data base tests
    precision = precisionPorcentageVector(malwareFeaturesMatrix, malwaresTestCount, softwareFeaturesMatrix, softwaresTestCount)

    #Generating the TSNE image
    matrixTSNE = TSNE(learning_rate=100).fit_transform(dataSet.getFeaturesMatrix())
    matplotlib.pyplot.scatter(matrixTSNE[:, 0], matrixTSNE[:, 1], c=dataSet.getSamplesTargetsVector())
    matplotlib.pyplot.savefig('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\mainProject\\SFAnalytics\\static\\img\\TSNE.png')
    #Generating the PCA image
    matrixPCA = PCA().fit_transform(dataSet.getFeaturesMatrix())
    matplotlib.pyplot.scatter(matrixPCA[:, 0], matrixPCA[:, 1], c=dataSet.getSamplesTargetsVector())
    matplotlib.pyplot.savefig('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\mainProject\\SFAnalytics\\static\\img\\PCA.png')
    return render(request, 'SFAnalytics/dataBaseAnalysisTemplate.html', {'precision' : precision})

#view from malwareResult template
def malwareResultViewFinal(request):
    """Function to show all the extracted features from sample and the results from machine learning"""
    #Tests
    fileName = '7zip'
    opcodes = OpCodeFile('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\7zFM.exe')
    strings = Strings('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\7zFM.exe')
    pef = PEHandle('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\7zFM.exe')

    #Loading dataset
    iris = load_iris()
    decisionTree = tree.DecisionTreeClassifier()
    decisionTree = decisionTree.fit(iris.data, iris.target)
    dot_data = tree.export_graphviz(decisionTree, out_file=None, feature_names=iris.feature_names, class_names=iris.target_names, filled=True, rounded=True, special_characters=True)
    #Building the tree image
    graph = graphviz.Source(dot_data)
    graph.format = 'png'
    graph.render('C:\\Users\\lucas\\Documents\\TCC\\MalwareAnalysis\\mainProject\\SFAnalytics\\static\\img\\tree')

    #Data to build te chart
    entryFileDataEntropy = pef.getDataSectionEntropy()
    entryFileDataEntropy = pef.getTextSectionEntropy()
    #bulding the chart view of malware software and the entry file
    malwareEntropy = []
    softwareEntropy = []
    for entry in EntryFile.objects.all():
        if entry.malware:
            malwareEntropy.append([float('{}'.format(entry.dataSectionEntropy)), float('{}'.format(entry.textSectionEntropy))])
        else:
            softwareEntropy.append([float('{}'.format(entry.dataSectionEntropy)), float('{}'.format(entry.textSectionEntropy))])

    #Making the instructions available at the chart
    instructionsVector = []
    porcentageVector = []
    opCount = opcodes.getCount()
    for op in opcodes.getOperations():
        instructionsVector.append(op.op)
        porcentageVector.append(float('{0:.4f}'.format(100 * (op.num/opCount))))

    totalPorcentage = 0
    #Making others operations Feature
    for porcentage in porcentageVector:
        totalPorcentage += porcentage

    instructionsVector.append('others')
    othersPorcentage = float('{0:.4f}'.format(100 - totalPorcentage))
    if othersPorcentage < 0:
        othersPorcentage = 0.00

    porcentageVector.append(othersPorcentage)

    #Making strings view
    #The Matrix is necessary to make a page view
    stringsMatrix = []
    aux = []
    i = 0
    while i < len(strings.getStrings()):
        #This condition determines the number of lines at the interface
        #clean aux to new page
        aux = []
        count = 0
        while count < 50:
            if i < len(strings.getStrings()):
                aux.append(strings.getStrings()[i])
            else:
                aux.append('')
            i+=1
            count+=1
        #appending on matrix
        stringsMatrix.append(aux)

    #Same thing as before
    #It's the "same" view, only different data
    i = 0
    dllsMatrix = []
    while i < len(pef.getDlls()):
        aux = []
        count = 0
        while count < 20:
            if i < len(pef.getDlls()):
                aux.append(pef.getDlls()[i])
            else:
                aux.append('')
            i+=1
            count+=1
        #appending on matrix
        dllsMatrix.append(aux)

    return render(request, 'SFAnalytics/malwareResultTemplateFinal.html', { 'treeViewData' : dot_data, 'fileName' : fileName, 'instructions' : instructionsVector, 'porcentage' : porcentageVector,
                                                                            'softwareEntropy' : softwareEntropy, 'malwareEntropy' : malwareEntropy, 'dlls' : dllsMatrix,
                                                                            'strings' : stringsMatrix})

#view from malwareResult template
def malwareResultView(request):
    # Retrieves the first file of the upload folder
    analysisPath = './SFAnalytics/DataBase/Analysis/'
    uploadPath = './SFAnalytics/DataBase/Uploads/'
    #removing files from temp path
    analysisList = os.listdir(analysisPath)
    for f in analysisList:
        os.remove('{}{}'.format(analysisPath, f))
    # Retriaving file uploaded
    filesList = os.listdir(uploadPath)
    uploadedFile = filesList[0]
    #moving file
    os.rename('{}{}'.format(uploadPath, uploadedFile), '{}{}'.format(analysisPath, uploadedFile))
    path = '{}{}'.format(analysisPath, uploadedFile)
    #This is to hold in the future the value of the classification
    handlePE = DllView(path)
    dlls = handlePE.getDllListView()
    fileHashs = HashTable(path)
    opcodes = OpCodeView(path).getOpcodeListView()
    strings = StringView(path).getStringListView()
    isMalware = uploadedFileClassification(opcodes, dlls, handlePE.getDataSectionEntropy(), handlePE.getTextSectionEntropy())
    fileAnalysed = AnalysedFile(uploadedFile, handlePE.getDataSectionEntropy(), handlePE.getTextSectionEntropy(), isMalware)
    return render(request, 'SFAnalytics/malwareResultTemplate.html', {'opcodes' : opcodes, 'strings' : strings, 'dlls' : dlls, 'fileAnalysed' : fileAnalysed})

def uploadDataBaseView(request):
    if request.method == 'POST':
        form = UploadDataBaseForm(request.POST, request.FILES)
        malwaresPath = './SFAnalytics/DataBase/Malwares/'
        softwaresPath = './SFAnalytics/DataBase/Softwares/'
        if form.is_valid():
            #Cleaning DataBase
            OpcodeList.objects.all().delete()
            OpcodeToEntry.objects.all().delete()

            DllList.objects.all().delete()
            DllToEntry.objects.all().delete()

            StringList.objects.all().delete()
            StringToEntry.objects.all().delete()

            EntryFile.objects.all().delete()

            #Turning off the panic window
            SEM_NOGPFAULTERRORBOX = 0x0002 # From MSDN
            ctypes.windll.kernel32.SetErrorMode(SEM_NOGPFAULTERRORBOX) #Setting the window off

            #HashList to don't repeat a file
            hashList = []
            for m in request.FILES.getlist('malwareUpload'):
                HandleFile.saveFile(m, malwaresPath)
                addLearn(m, malwaresPath, True)
            for s in request.FILES.getlist('softwareUpload'):
                HandleFile.saveFile(s, softwaresPath)
                addLearn(s, softwaresPath, False)
            return HttpResponseRedirect('/admin/')
    else:
        form = UploadDataBaseForm()
    return render(request, 'SFAnalytics/uploadDataBaseTemplate.html', {'form': form})

#Function to don't add a repeated file
def nonRepeat(hashFile, hashList):
    for h in hashList:
        if h.getHashMd5() == hashFile.getHashMd5() and h.getHashSha256() == hashFile.getHashSha256():
            return False
    return True

#This is to handle the addition of a string to DB
#Receives a string object
def handleStrings(strings, entryFileId):
    # Getting strings from DataBase, this makes things faster
    dataBaseStrings = StringList.objects.all()
    count = round(strings.getCount() * 0.1)
    fileStrings = strings.getStrings()[:count]
    i = count - 1
    idNumber = len(dataBaseStrings)
    while i >= 0:
        if len(fileStrings[i]) > 250:
            i-=1
            continue
        j = len(dataBaseStrings) - 1
        while j >= 0:
            if dataBaseStrings[j].string == fileStrings[i]:
                stringREntry = StringToEntry(id_string=dataBaseStrings[j].id, id_entry=entryFileId)
                stringREntry.save()
                break
            j-=1
        #If j is -1, theres no equal value on DB.
        if j == -1:
            idNumber+=1
            stringItem = StringList(id=idNumber,string=fileStrings[i])
            stringItem.save()
            stringREntry = StringToEntry(id_string=idNumber, id_entry=entryFileId)
            stringREntry.save()

        i-=1

#This is to handle the addition of a opcode to DB
#Receives a opcode object
def handleOpCodes(opcodes, entryFileId):
    #Getting opcodes from DataBase
    opCount = opcodes.getCount()
    opcodesInDataBase = OpcodeList.objects.all()
    idNumber = len(opcodesInDataBase)
    for opInfo in opcodes.getOperations():
        if len(opInfo.op) > 10:
            continue
        j = len(opcodesInDataBase) - 1
        while j >= 0:
            #if opcode already exists
            if opInfo.op == opcodesInDataBase[j].instruction:
                opREntry = OpcodeToEntry(id_entry=entryFileId, id_opcode=opcodesInDataBase[j].id, porcentage=round(((opInfo.num/opCount)*100), 4))
                opREntry.save()
                break
            j-=1
        #If j is -1, theres no equal value on DB.
        #It's a new dll
        if j == -1:
            idNumber+=1
            op = opInfo.op
            opItem = OpcodeList(id=idNumber,instruction=op)
            opItem.save()
            opREntry = OpcodeToEntry(id_entry=entryFileId, id_opcode=idNumber, porcentage=round(((opInfo.num/opCount)*100), 4))
            opREntry.save()

#This is to handle the addition of a dll to DB
#Receives a dll list
def handleDlls(dlls, entryFileId):
    dllsInDataBase = DllList.objects.all()
    idNumber = len(dllsInDataBase)
    for dll in dlls:
        #Don't accept dll name lengths higher than 100 bytes
        if len(dll) > 100:
            continue
        j = len(dllsInDataBase) - 1
        while j >= 0:
            #if the dll already exists in the feature list
            if dll == dllsInDataBase[j].name:
                #adding code to entry
                dllREntry = DllToEntry(id_entry=entryFileId, id_dll=dllsInDataBase[j].id)
                dllREntry.save()
                break
            j-=1
        #if it's a new dll
        if j == -1:
            idNumber+=1
            dllItem = DllList(id=idNumber, name=dll)
            dllItem.save()
            dllREntry = DllToEntry(id_entry=entryFileId, id_dll=idNumber)
            dllREntry.save()

#This function handles each file uploaded for learning
#It adds file features to the database if the feature extraction went ok, if not, only returns the error code
def addLearn(data, path, malwareLabel):
    path = '{}{}'.format(path, data.name)
    pe = PEHandle(path)
    fileHashs = HashTable(path)
    opcodes = OpCodeFile(path)
    strings = Strings(path)
    returnCode = opcodes.getReturnCode()
    #This makes sure that it was possible to extract opcodes
    if returnCode == 0:
        #Determining the id number
        idEntryFile = len(EntryFile.objects.all()) + 1
        #Saving entry file
        entry = EntryFile(id=idEntryFile, hashMd5=fileHashs.getHashMd5(), hashSha256=fileHashs.getHashSha256(), malware=malwareLabel,
                          dataSectionEntropy=pe.getDataSectionEntropy(), textSectionEntropy=pe.getTextSectionEntropy())
        entry.save()
        # Getting strings from DataBase, this makes things faster
        dataBaseStrings = StringList.objects.all()
        fileStrings = strings.getStrings()
        # Adding strings to StringList
        #handleStrings(strings, idEntryFile)
        # Adding opcodes to OpcodeList
        handleOpCodes(opcodes, idEntryFile)
        # Adding dlls to DllList
        #handleDlls(pe.getDlls(), idEntryFile)

    return returnCode

class FeaturesInSample(object):
    @staticmethod
    def __getOpcodeFeaturePorcentage(opcodeFeature, opcodesInSample):
        for opcode in opcodesInSample:
            if opcodeFeature.id == opcode.id:
                return opcode.porcentage

        return 0

    @staticmethod
    def getOpcodesFeatureArray(sampleID):
        opcodesInSample = OpcodeToEntry.objects.filter(id_entry=sampleID)
        opcodesFeature = OpcodeList.objects.all()
        porcentagesOfOpcodes = []
        for opcodeFeature in opcodesFeature:
            porcentagesOfOpcodes.append(FeaturesInSample.__getOpcodeFeaturePorcentage(opcodeFeature, opcodesInSample))

        return porcentagesOfOpcodes

    @staticmethod
    def __getDllFeature(dllFeature, dllsInSample):
        for dll in dllsInSample:
            if dllFeature.id == dll.id:
                return 1

        return 0

    @staticmethod
    def getDllsFeatureArray(sampleID):
        dllsInSample = DllToEntry.objects.filter(id_entry=sampleID)
        dllsFeature = DllList.objects.all()
        existingDlls = []
        for dllFeature in dllsFeature:
            existingDlls.append(FeaturesInSample.__getDllFeature(dllFeature, dllsInSample))

        return existingDlls

def uploadedFileClassification(fileOpcodes, fileDlls, fileDataSectionEntropy, fileTextSectionEntropy):
    samples = EntryFile.objects.all()
    operations = OpcodeList.objects.all()
    dlls = DllList.objects.all()

    #function main vector
    featuresVector = numpy.array([])
    targetsVector = []

    #building the featuresVector
    for sample in samples:
        #Extracting features
        features = []
        features = numpy.concatenate((features, FeaturesInSample.getOpcodesFeatureArray(sample.id)), axis=0)
        features = numpy.concatenate((features, FeaturesInSample.getDllsFeatureArray(sample.id)), axis=0)
        #Data section entropy, and Text section Entropy features
        features = numpy.concatenate((features, [sample.dataSectionEntropy]), axis=0)
        features = numpy.concatenate((features, [sample.textSectionEntropy]), axis=0)
        #Making the feature matrix
        if len(featuresVector) == 0:
            featuresVector = numpy.array(features)
        else:
            featuresVector = numpy.vstack((featuresVector, features))
        #Extracting target sample
        if sample.malware:
            targetsVector.append(1)
        else:
            targetsVector.append(0)

    #Extracting features names
    featureNames = []

    #Operations Names
    for operation in operations:
        featureNames.append(operation.instruction)
    #Dlls Names
    for dll in dlls:
        featureNames.append(dll.name)

    #Appending Data section entropy, and Text section Entropy names
    featureNames.append('dataSectionEntropy')
    featureNames.append('textSectionEntropy')

    #Classifing file
    sampleFeatures = []
    #searching
    for operation in operations:
        i = 0
        #searching for the opcode
        while i < len(fileOpcodes):
            if(operation.id == fileOpcodes[i].index):
                sampleFeatures.append(fileOpcodes[i].porcentage)
                break
            i+=1
        #if don't find a match, places a zero
        if i == len(fileOpcodes):
            sampleFeatures.append(0)


    for dll in dlls:
        i = 0
        #It's 1 in case it has the dll
        while i < len(fileDlls):
            if(dll.id == fileDlls[i].index):
                sampleFeatures.append(1)
                break
            i+=1
        #It's 1 in case it has the dll
        if i == len(fileDlls):
            sampleFeatures.append(0)

    sampleFeatures.append(fileDataSectionEntropy)
    sampleFeatures.append(fileTextSectionEntropy)

    clf = tree.DecisionTreeClassifier()
    clf = clf.fit(featuresVector, targetsVector)

    #1 is malware
    if clf.predict(sampleFeatures) == 1:
        return True;

    #0 is not
    return False;

class FeaturesInDataBase(object):
    def __init__(self):
        """This class builds everything to the machine learning, features matrix, features target and features names"""
        self.featuresMatrix = []
        self.samplesTargetVector = []
        opcodeList = OpcodeList.objects.all()
        stringList = StringList.objects.all()
        dllList = DllList.objects.all()
        entryFiles = EntryFile.objects.all()
        for entryFile in entryFiles:
            featuresLine = self.__entryFeatureToEntry(entryFile) + self.__opcodesToEntry(entryFile.id, opcodeList) + self.__stringsToEntry(entryFile.id, stringList) + self.__dllsToEntry(entryFile.id, dllList)
            if len(self.featuresMatrix) == 0:
                self.featuresMatrix = numpy.array(featuresLine)
            else:
                self.featuresMatrix = numpy.vstack((self.featuresMatrix, featuresLine))

            #1 to Malware and 0 to Software
            if entryFile.malware :
                self.samplesTargetVector.append(1)
            else:
                self.samplesTargetVector.append(0)

        self.featuresNames = self.__entryFeaturesNames() + self.__operationsNames(opcodeList) + self.__dllsNames(dllList) + self.__stringsNames(stringList)
        self.samplesTargetsNames = self.__targetsNames()

    def getSamplesTargetsNames(self):
        return self.samplesTargetsNames

    def getSamplesTargetsVector(self):
        return self.samplesTargetVector

    def getFeaturesNames(self):
        return self.featuresNames

    def getFeaturesMatrix(self):
        return self.featuresMatrix

    def __entryFeatureToEntry(self, entry):
        return [float('{}'.format(entry.dataSectionEntropy)), float('{}'.format(entry.textSectionEntropy))]

    def __opcodesToEntry(self, id, opcodesList):
        """"Returns a list of the opcodes porcentage of an entrySample"""
        if opcodesList == []:
            return []
        opcodesInSample = OpcodeToEntry.objects.filter(id_entry = id)
        opcodesPorcentageFeaturesVector = []
        for opcode in opcodesList:
            length = len(opcodesPorcentageFeaturesVector)
            for opcodeInSample in opcodesInSample:
                if opcodeInSample.id_opcode == opcode.id:
                    opcodesPorcentageFeaturesVector.append(opcodeInSample.porcentage)
                    break
            #if the length of opcodeFeatureVetor doesn't change, it means that it doesn't have any of the intructions
            if length == len(opcodesPorcentageFeaturesVector):
                opcodesPorcentageFeaturesVector.append(0)

        instructionsTotalPorcentage = 0.0
        for opcodePorcentage in opcodesPorcentageFeaturesVector:
            instructionsTotalPorcentage += opcodePorcentage

        #This transformation is take the round delta out
        othersIntructionsPorcentageFeature = 100.0 - float('{0:.4f}'.format(instructionsTotalPorcentage))
        opcodesPorcentageFeaturesVector.append(othersIntructionsPorcentageFeature)
        return opcodesPorcentageFeaturesVector

    def __stringsToEntry(self, id, stringsList):
        """Return a list with every present string in the EntrySample (1 if present, 0 if not)."""
        if stringsList == [] :
            return []
        stringsInSample = StringToEntry.objects.filter(id_entry = id)
        stringsFeaturesVector = []
        for string in stringsList:
            length = len(stringsFeaturesVector)
            for stringInSample in stringsInSample:
                if string.id == stringInSample.id_string:
                    stringsFeaturesVector.append(1)
                    break
            if length == len(stringsFeaturesVector):
                stringsFeaturesVector.append(0)
        return stringsFeaturesVector

    def __dllsToEntry(self, id, dllsList):
        """Return a list with every present string in the EntrySample (1 if present, 0 if not)."""
        if dllsList == []:
            return []
        dllsInSample = DllToEntry.objects.filter(id_entry = id)
        dllsFeaturesVector = []
        for dll in dllsList:
            length = len(dllsFeaturesVector)
            for dllInSample in dllsInSample:
                if dll.id == dllInSample.id_dll:
                    dllsFeaturesVector.append(1)
                    break
            if length == len(dllsFeaturesVector):
                dllsFeaturesVector.append(1)
        return dllsFeaturesVector

    def __operationsNames(self, operationsList):
        operationsNames = []
        for operation in operationsList:
            operationsNames.append(operation.instruction)
        operationsNames.append('others')
        return operationsNames

    def __dllsNames(self, dllsList):
        dllsNames = []
        for dll in dllsList:
            dllsNames.append(dll.name)
        return dllsNames

    def __stringsNames(self, stringsList):
        stringsNames = []
        for string in stringsList:
            stringsNames.append(string.string)
        return stringsNames

    def __entryFeaturesNames(self):
        return ['dataSectionEntropy', 'textSectionEntropy']

    def __targetsNames(self):
        return ['Software', 'Malware']
