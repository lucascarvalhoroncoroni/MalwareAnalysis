import os
import math
import numpy
from django.shortcuts import render
from django.http import HttpResponseRedirect
from .forms import *
from .tools import *
from .models import *

#struct for each line of the info showing
class OpCodeViewLine(object):
    def __init__(self, name, porcentage, index):
        self.name = name
        self.index = index
        self.porcentage = porcentage

#class for showing opcodes as features
class OpCodeView(object):
    #Extracting features
    def __init__(self, path):
        opcode = OpCodeFile(path)
        opcodeList = opcode.getOperations()
        self.opcodeCount = opcode.getCount()
        self.opcodeFeatures = OpCodeList.objects.all()
        self.opcodeListView = []
        for singleOpcode in opcodeList:
            name = singleOpcode.op
            porcentage = (singleOpcode.num / self.opcodeCount) * 100
            porcentage = float('{0:.4f}'.format(porcentage))
            index = self.__opcodeFeature(singleOpcode.op)
            self.opcodeListView.append(OpCodeViewLine(name, porcentage, index))

    #Extracting index
    def __opcodeFeature(self, opcode):
        for feature in self.opcodeFeatures:
            if feature.instruction == opcode:
                return feature.id
        return 0

    #Result
    def getOpcodeListView(self):
        return self.opcodeListView

    def getOpcodeCount(self):
        self.opcodeCount

#struct for each string line
class StringViewLine(object):
    def __init__(self, string, index):
        self.string = string
        self.index = index

#class for showing strings as features
class StringView(object):
    def __init__(self, path):
        strings = Strings(path)
        self.stringCount = round(strings.getCount() *  0.1)
        stringList = strings.getStrings()[:self.stringCount]
        self.stringFeatures = StringList.objects.all()
        self.stringListView = []
        for string in stringList:
            index = self.__stringFeature(string)
            self.stringListView.append(StringViewLine(string, index))

    def __stringFeature(self, string):
        for singleString in self.stringFeatures:
            if singleString.string == string:
                return singleString.id
        return 0

    def getStringListView(self):
        return self.stringListView

    def getStringCount(self):
        return self.stringCount

#struct for each dll line
class DllViewLine(object):
    def __init__(self, name, index):
        self.name = name
        self.index = index

#class for showing dlls as features
class DllView(object):
    def __init__(self, path):
        pe = PEHandle(path)
        dllList = pe.getDlls()
        self.dataSectionEntropy = pe.getDataSectionEntropy()
        self.textSectionEntropy = pe.getTextSectionEntropy()
        self.dllFeatures = DllList.objects.all()
        self.dllListView = []
        for dll in dllList:
            index = self.__dllFeature(dll)
            self.dllListView.append(DllViewLine(dll, index))

    def __dllFeature(self, dll):
        for singleDll in self.dllFeatures:
            if singleDll.name == dll:
                return singleDll.id
        return 0

    def getTextSectionEntropy(self):
        return self.textSectionEntropy

    def getDataSectionEntropy(self):
        return self.dataSectionEntropy

    def getDllListView(self):
        return self.dllListView

#class to handle additional information of a fileUpload
class AnalysedFile(object):
    def __init__(self, fileName, dataEntropy, textEntropy, isMalware):
        self.name = fileName
        self.dataSectionEntropy = dataEntropy
        self.textSectionEntropy = textEntropy
        self.isMalware = isMalware

#view from upload template
def uploadView(request):
    if request.method == 'POST':
        #this is a simple way, the next step is to add it to the model
        form = UploadSuspiciousFileForm(request.POST, request.FILES)
        if form.is_valid():
            HandleFile.saveFile(request.FILES['fileUpload'], './SFAnalytics/DataBase/Uploads/')
            return HttpResponseRedirect('/SFAnalytics/malwareResult/')
    else:
        form = UploadSuspiciousFileForm()

    return render(request, 'SFAnalytics/uploadTemplate.html', {'form' : form})

#view from malwareResult template
def malwareResultView(request):
    # Retrieves the first file of the upload folder
    analysisPath = './SFAnalytics/DataBase/Analysis/'
    uploadPath = './SFAnalytics/DataBase/Uploads/'
    #removing files from temp path
    analysisList = os.listdir(analysisPath)
    for f in analysisList:
        os.remove('{}{}'.format(analysisPath, f))
    # Retriaving file uploaded
    filesList = os.listdir(uploadPath)
    uploadedFile = filesList[0]
    #moving file
    os.rename('{}{}'.format(uploadPath, uploadedFile), '{}{}'.format(analysisPath, uploadedFile))
    path = '{}{}'.format(analysisPath, uploadedFile)
    #This is to hold in the future the value of the classification
    handlePE = DllView(path)
    dlls = handlePE.getDllListView()
    fileHashs = HashTable(path)
    opcodes = OpCodeView(path).getOpcodeListView()
    strings = StringView(path).getStringListView()
    isMalware = uploadedFileClassification(opcodes, dlls, handlePE.getDataSectionEntropy(), handlePE.getTextSectionEntropy())
    fileAnalysed = AnalysedFile(uploadedFile, handlePE.getDataSectionEntropy(), handlePE.getTextSectionEntropy(), isMalware)
    return render(request, 'SFAnalytics/malwareResultTemplate.html', {'opcodes' : opcodes, 'strings' : strings, 'dlls' : dlls, 'fileAnalysed' : fileAnalysed})

def uploadDataBaseView(request):
    if request.method == 'POST':
        form = UploadDataBaseForm(request.POST, request.FILES)
        malwaresPath = './SFAnalytics/DataBase/Malwares/'
        softwaresPath = './SFAnalytics/DataBase/Softwares/'
        if form.is_valid():
            #Cleaning DataBase
            OpCodeList.objects.all().delete()
            OpcodeToEntry.objects.all().delete()

            DllList.objects.all().delete()
            DllToEntry.objects.all().delete()

            StringList.objects.all().delete()
            StringToEntry.objects.all().delete()

            EntryFile.objects.all().delete()

            #HashList to don't repeat a file
            hashList = []
            for m in request.FILES.getlist('malwareUpload'):
                HandleFile.saveFile(m, malwaresPath)
                completePath = '{}{}'.format(malwaresPath, m.name)
                h = HashTable(completePath)
                #Avoiding reapeated files
                if nonRepeat(h, hashList):
                    addLearn(m, malwaresPath, True)
                    hashList.append(h)
            for s in request.FILES.getlist('softwareUpload'):
                HandleFile.saveFile(s, softwaresPath)
                completePath = '{}{}'.format(softwaresPath, s.name)
                h = HashTable(completePath)
                #Avoiding reapeated files
                if nonRepeat(h, hashList):
                    addLearn(s, softwaresPath, False)
                    hashList.append(h)
            return HttpResponseRedirect('/admin/')
    else:
        form = UploadDataBaseForm()
    return render(request, 'SFAnalytics/uploadDataBaseTemplate.html', {'form': form})

#Function to don't add a repeated file
def nonRepeat(hashFile, hashList):
    for h in hashList:
        if h.getHashMd5() == hashFile.getHashMd5() and h.getHashSha256() == hashFile.getHashSha256():
            return False
    return True

#This is to handle the addition of a string to DB
#Receives a string object
def handleStrings(strings, entryFileId):
    # Getting strings from DataBase, this makes things faster
    dataBaseStrings = StringList.objects.all()
    count = round(strings.getCount() * 0.1)
    fileStrings = strings.getStrings()[:count]
    i = count - 1
    idNumber = len(dataBaseStrings)
    while i >= 0:
        if len(fileStrings[i]) > 250:
            i-=1
            continue
        j = len(dataBaseStrings) - 1
        while j >= 0:
            if dataBaseStrings[j].string == fileStrings[i]:
                stringREntry = StringToEntry(id_string=dataBaseStrings[j].id, id_entry=entryFileId)
                stringREntry.save()
                break
            j-=1
        #If j is -1, theres no equal value on DB.
        if j == -1:
            idNumber+=1
            stringItem = StringList(id=idNumber,string=fileStrings[i])
            stringItem.save()
            stringREntry = StringToEntry(id_string=idNumber, id_entry=entryFileId)
            stringREntry.save()

        i-=1

#This is to handle the addition of a opcode to DB
#Receives a opcode object
def handleOpCodes(opcodes, entryFileId):
    #Getting opcodes from DataBase
    opCount = opcodes.getCount()
    opcodesInDataBase = OpCodeList.objects.all()
    idNumber = len(opcodesInDataBase)
    for opInfo in opcodes.getOperations():
        if len(opInfo.op) > 10:
            continue
        j = len(opcodesInDataBase) - 1
        while j >= 0:
            #if opcode already exists
            if opInfo.op == opcodesInDataBase[j].instruction:
                opREntry = OpcodeToEntry(id_entry=entryFileId, id_opcode=opcodesInDataBase[j].id, porcentage=round(((opInfo.num/opCount)*100), 4))
                opREntry.save()
                break
            j-=1
        #If j is -1, theres no equal value on DB.
        #It's a new dll
        if j == -1:
            idNumber+=1
            op = opInfo.op
            opItem = OpCodeList(id=idNumber,instruction=op)
            opItem.save()
            opREntry = OpcodeToEntry(id_entry=entryFileId, id_opcode=idNumber, porcentage=round(((opInfo.num/opCount)*100), 4))
            opREntry.save()

#This is to handle the addition of a dll to DB
#Receives a dll list
def handleDlls(dlls, entryFileId):
    dllsInDataBase = DllList.objects.all()
    idNumber = len(dllsInDataBase)
    for dll in dlls:
        #Don't accept dll name lengths higher than 100 bytes
        if len(dll) > 100:
            continue
        j = len(dllsInDataBase) - 1
        while j >= 0:
            #if the dll already exists in the feature list
            if dll == dllsInDataBase[j].name:
                #adding code to entry
                dllREntry = DllToEntry(id_entry=entryFileId, id_dll=dllsInDataBase[j].id)
                dllREntry.save()
                break
            j-=1
        #if it's a new dll
        if j == -1:
            idNumber+=1
            dllItem = DllList(id=idNumber, name=dll)
            dllItem.save()
            dllREntry = DllToEntry(id_entry=entryFileId, id_dll=idNumber)
            dllREntry.save()

#This function handles each file uploaded for learning
def addLearn(data, path, malwareLabel):
    path = '{}{}'.format(path, data.name)
    pe = PEHandle(path)
    fileHashs = HashTable(path)
    opcodes = OpCodeFile(path)
    strings = Strings(path)
    #Determining the id number
    idEntryFile = len(EntryFile.objects.all()) + 1
    #Saving entry file
    entry = EntryFile(id=idEntryFile, hashMd5=fileHashs.getHashMd5(), hashSha256=fileHashs.getHashSha256(), malware=malwareLabel,
                      dataSectionEntropy=pe.getDataSectionEntropy(), textSectionEntropy=pe.getTextSectionEntropy())
    entry.save()
    # Getting strings from DataBase, this makes things faster
    dataBaseStrings = StringList.objects.all()
    fileStrings = strings.getStrings()
    # Adding strings to StringList
    handleStrings(strings, idEntryFile)
    # Adding opcodes to OpCodeList
    handleOpCodes(opcodes, idEntryFile)
    # Adding dlls to DllList
    handleDlls(pe.getDlls(), idEntryFile)

class malwareDataSet(object):
    __instance = None
    @property
    def data(self):
        return self.__data

    @data.setter
    def data(self, value):
        self.__data = value

    @property
    def target(self):
        return self.target_names

    @target.setter
    def target(self, value):
        self.__target = value

    @property
    def target_names(self):
        return self.target_names

    @target_names.setter
    def target_names(self, value):
        self.__target_names = value

    @staticmethod
    def instance():
        if not Singleton.__instance:
            Singleton.__instance = malwareDataSet()
        return Singleton.__instance

def uploadedFileClassification(fileOpcodes, fileDlls, fileDataSectionEntropy, fileTextSectionEntropy):
    samples = EntryFile.objects.all()
    operations = OpCodeList.objects.all()
    dlls = DllList.objects.all()

    #function main vector
    featuresVector = None
    targetsVector = []

    #building the featuresVector
    for sample in samples:
        #Extracting target sample
        if sample.malware:
            target.append(1)
        else:
            target.append(0)

        #Extracting features
        feature = []
        opcodesInSample = OpcodeToEntry.objects.filter(id_entry=sample.id)
        dllsInSample = DllToEntry.objects.filter(id_entry=sample.id)
        #building opcodes
        for operation in operations:
            i = 0
            #searching for the opcode
            while i < len(opcodesInSample):
                if(operation.id == opcodesInSample[i].id_opcode):
                    feature.append(opcodesInSample[i].porcentage)
                    break
                i+=1
            #if don't find a match, places a zero
            if i == len(opcodesInSample):
                feature[operation.instruction] = 0
        #building dlls
        for dll in dlls:
            i = 0
            #It's 1 in case it has the dll
            while i < len(dllsInSample):
                if(dll.id == dllsInSample[i].id_dll):
                    feature.append(1)
                i+=1
            #It's 1 in case it has the dll
            if i == len(dllsInSample):
                feature.append(0)

        #Starting the Features Matrix
        if not featuresVector:
            featuresVector = numpy.array(feature)
        else:
            featuresVector = numpy.vstack(feature)

        #Data section entropy, and Text section Entropy features
        featuresVector.append(sample.dataSectionEntropy)
        featuresVector.append(sample.textSectionEntropy)

    #Extracting features names
    featureNames = []

    for operation in operations:
        featureNames.append(operation.instruction)
    for dll in dlls:
        featureNames.append(dll.name)

    #Appending Data section entropy, and Text section Entropy names
    featureNames.append('dataSectionEntropy')
    featureNames.append('textSectionEntropy')

    #Classifing file
    sampleFeatures = []
    #searching
    for operation in operations:
        i = 0
        #searching for the opcode
        while i < len(fileOpcodes):
            if(operation.id == fileOpcodes[i].index):
                sampleFeatures.append(fileOpcodes[i].porcentage)
                break
            i+=1
        #if don't find a match, places a zero
        if i == len(opcodesInSample):
            sampleFeatures.append(0)


    for dll in dlls:
        i = 0
        #It's 1 in case it has the dll
        while i < len(dllsInSample):
            if(dll.id == fileDlls[i].index):
                sampleFeatures.append(1)
            i+=1
        #It's 1 in case it has the dll
        if i == len(dllsInSample):
            sampleFeatures.append(0)

    sampleFeatures.append(fileDataSectionEntropy, fileTextSectionEntropy)

    tree = tree.DecisionTreeClassifier()
    tree = tree.fit(featuresVector, targetsVector)

    #1 is malware
    if tree.predict(sampleFeatures) == 1:
        return True;

    #0 is not
    return False;
